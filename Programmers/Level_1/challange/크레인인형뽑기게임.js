/* 문제 이해하기
N * N 정사각형의 2차원 배열에서 moves 배열에 해당하는 크레인 탐색 동작을 수행한다.
인덱스의 값 중 0은 비어있음을 의미하고, 그 이외의 값은 아이콘을 의미한다.
즉, 0이 아니면 해당 열의 인형 뽑기를 수행하여 뽑은 자리는 0으로 하여 비어있음을 처리하고
뽑은 인형의 값을 담을 공간을 배열로 담아서 현재 뽑은 인형과 마지막 인형이 같으면 인형이 사라지고, 사라진 인형의 갯수를 카운트한다.
최종적으로는 크레인의 동작을 모두 마쳤을 때, 해당 조건으로 사라진 인형의 갯수를 반환한다.

- 배열 탐색
2차원 배열에서 0이 되는 값은 moves 액션에 없음 => 탐색되는 열이 같기 때문에 고정시킨다.
배열을 탐색 하면서 그 요소에서 0이 되는 값이 없다면 뽑을 인형이 존재하므로
해당 인덱스의 값을 0으로 하여 비어있도록 처리한다.

- stack 처리
연속된 아이콘이 들어오는 경우 stack의 마지막 요소를 지우고, answer를 증가시킨다.
그렇지 않은 경우 stack에 해당 요소를 push 한다.
현재 뽑은 인형 + stack의 마지막 원소가 같다면 stack을 pop 하여 마지막 요소 제거 및 answer의 값을 2 증가 시킨다.
*/

function solution(board, moves) {
  let cnt = 0;
  const stack = [];

  for (let i = 0; i < moves.length; i++) {
    // 크레인 동작 사이클
    // moves에 담긴 값은 1부터 시작하고 index는 0부터 시작하므로 -1을 해서 맞춰준다.
    const col = moves[i] - 1;
    for (let row = 0; row < board.length; row++) {
      // 열(col)값은 고정이므로 행(row)값을 반복으로 돌면서 인형이 있으면 관련 코드 실행
      const pick = board[row][col];
      if (pick) {
        // 해당 열에 0 이외의 값이 있는지 탐색해서 다른 값이 있다면
        board[row][col] = 0; // 해당 위치의 인덱스 값을 0으로 바꾸고 (해당 인형을 크레인이 뽑은 상태)
        // 스택에 마지막 담긴 인형 + 현재 꺼낸 인형이 같으면
        if (stack[stack.length - 1] === pick) {
          stack.pop(); // 스택에서 마지막 인형 제거
          cnt += 2; // count 2 증가 시킨다.
        } else {
          stack.push(pick); // 그렇지 않으면 해당 스택에 현재 뽑은 인형을 쌓는다.
        }
        break; // 해당 열에서 인형을 뽑았으면 크레인의 탐색을 멈추고 다음 moves 배열의 사이클을 진행한다.
      }
    }
  }
  return cnt;
}

const board = [
  [0, 0, 0, 0, 0],
  [0, 0, 1, 0, 3],
  [0, 2, 5, 0, 1],
  [4, 2, 4, 4, 2],
  [3, 5, 1, 3, 1],
];
const moves = [1, 5, 3, 5, 1, 2, 1, 4];

console.log(solution(board, moves)); // 4
